---
title: Декартово дерево
mathjax: on
---

Set
===

Хотим сделать какую-нибудь структуру данных, которая будет вести себя как
_упорядоченное множество_. На примере целых чисел:

 * `add(x)` --- добавить число `x` во множество;
 * `find(x)` --- узнать, есть ли во множестве число `x`;
 * `remove(x)` --- удалить число `x` из множества;
 * `upper(x)` --- найти во множестве минимальное число, большее `x`.

[Двоичное дерево поиска](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)
========================

Назовём подвешенное дерево, у которого у каждой вершины есть не более двух 
(_левого_ и _правого_) поддеревьев, двоичным деревом. Пусть в каждой вершине
двоичного дерева записано число. Если для двоичного дерево выполняется, что
в любой вершине левого поддерева записано меньшее число, а в любой вершине
правого --- большее, то оно называется _двоичным деревом поиска_
(binary search tree, BST).

Заметим, что в двоичном дереве поиска не может быть двух одинаковых элементов.

### find

Научимся выполнять операцию `find`. Начнём в корне. Если в корне стоит нужное
значение, то вот оно. Если искомое значение меньше значения в корне, то пойдём
влево, иначе, пойдём вправо. Если в какой-то момент поддерева, в которое
хочется пойти, нет, то в дереве нет искомого элемента.

### add

Операция вставки элемента в дерево работает примерно также. Начинаем в корне,
выясняем, в какой дерево нужно вставить добавляемый элемент, перейдём туда.
Когда, в какой-то момент, дерева, в которое хочется перейти, нет, создадим
дерево из одной вершины и подвесим его туда.

### remove

Удаление делается несколько сложнее.

Найдём в дереве удаляемый элемент. Рассмотрим несколько случаев:

 * у него нет ни левого, ни правого поддеревьев. В этом случае нужно просто
   удалить эту вершину;
 * у него есть одно поддерево. Удалим эту вершину, подвесив вместо неё её
   единственное поддерево;
 * у него есть оба поддерева. В этом случае пойдём в правое поддерево, в
   нём пойдём до упора влево, поместим это значение в удаляемую вершину и
   удалим текущую (у неё есть только правое поддерево, поэтому удалять её
   мы уже умеем).

### upper

Встанем в вершину, для которой хочется найти следующую в дереве.

Если у неё есть правое поддерево, пойдём туда, а замем до упора влево.

Если у неё нет правого поддерева, то будем подниматься вверх, пока подъём
производится по ребру, идущему в правое поддерево.

Время работы
------------

Все операции выше выполняются за $O(h)$, где $h$ --- глубина дерева.

[Декартово дерево](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
=================

Определение
-----------

Рассмотрим пары чисел $\langle x_1, y_1 \rangle, \langle x_2, y_2 \rangle, \ldots
, \langle x_n, y_n \rangle$, при этом можно считать, что все $x$-ы и все $y$-и
различны.

Построим на этих точках _декартово дерево_ следующим образом:

1. Нарисуем эти точки на плоскости.
2. Выберем самую высокую точку (с наибольшим $y$-ом).
3. Разобъём вертикальной прямой точки на те, которые левее самой высокой и те,
 которые правее.
4. Ответ --- дерево с корнем в самой высокой вершине, левым поддеревом ---
 деревом, построенном аналогичным образом на вершинах левее, а правым ---
 на вершинах правее.

Свойства
--------

### Декартово дерево --- дерево поиска по $x$

Очевидно из определения (часть про "разобъём на те, что левее и на те, что
правее").

### Декартово дерево --- двоичная куча по $y$

Очевидно из определения (часть про "выберем самую высокую вершину").

Этимология
----------

В английском языке для обозначения декартова дерева используется слово
_treap_. Оно образовано от слов дерево (__tr__*e*e) и куча (h__eap__).

Если же попробовать провернуть такой же трюк с русским названием, получится
не так прозаично: __ку__ча + де**рево** = _курево_. Некоторые, однако,
используют слово _дерамида_ (**дер**ево + пир**амида**).

`split` и `merge`
-----------------

Все основные операции над декартовым деревом будем производить при помощи
операций `split` и `merge`.

`split`
-------

`split`($T$, $x$) принимает на вход дерево $T$ и разделяющий элемент $x$ и
возвращает два дерева $\langle T_1, T_2 \rangle$ такие, что в $T_1$ только
элементы из $T$, меньшие $x$, а в $T_2$ --- те из элементов $T$, которые больше
либо равны.


Если нужно разрезать пустое дерево, то результат --- пара из двух пустых
деревьев.
Чтобы разрезать непустое дерево по ключу $x$, нужно посмотреть, по какую 
сторону от корня проходит разрез ($x < T.x$ или нет). Пусть он проходит слева
от корня ($x < T.x$). Тогда $T_1$ получается как левое поддререво от разрезания
$T.left$ по ключу $x$, а правое --- как $T$, у которого левое поддерево
заменено на правый результат того же разрезания. Аналогично для $x \ge T.x$.

`merge`
-------

`merge`($T_1$, $T_2$) принимает два дерева таких, что каждый элемент $T_1$
меньше каждого элемента $T_2$ и возвращает $T$, в котором есть все элементы
обоих деревьев $T_1$ и $T_2$.

Нужно слить деревья $T_1$ и $T_2$. Если одно из них пустое, то нужно в качестве
результата вернуть непустое из них.

Иначе, оба дерева непусты. Корнем результирующего дерева может быть только
один из корней $T_1$ и $T_2$. А именно, тот, который выше. 

Пусть, без ограничения общности, корень $T_1$ выше корня $T_2$. 
Тогда левое поддерево результата совпадает с левым поддеревом $T_1$, а правое
является результатом объединения $T_1.right$ с $T_2$.

Остальные операции через `split` и `merge`
------------------------------------------

### Добавление

Чтобы добавить в декартово дерево элемент $x$, надо разрезать дерево по $x$
(получатся $T_1$ и $T_2$), затем склеить дерево $T_1$ с деревом из одного
элемента $x$, а результат --- с деревом $T_2$.

### Удаление

Удаление $x$ из $T$. Разрежем $T$ по $x$ ($=\langle T_1, T_2 \rangle$), затем 
$T_2$ по $x+1$ ($=\langle T_3, T_4 \rangle$) и объеденить `merge`($T_1, T_4$).

Как выбирать ключи $y$?
-----------------------

Случайно. Тогда среднее время работы будет составлять $O(\log n)$ на запрос.

[Реализация](/src/CartesianTree.java)
----------

~~~~~~~~~~~~~~~~~java
static Random rnd = new Random(3);

static class Node {
    int x;
    int y;
    int cnt;

    Node left, right;

    Node(int x) {
        this.x = x;
        y = rnd.nextInt();
        cnt = 1;
        left = right = null;
    }
}

static int cnt(Node t) {
    return t == null ? 0 : t.cnt;
}

static void update(Node t) {
    if (t != null) {
        t.cnt = cnt(t.left) + 1 + cnt(t.right);
    }
}

static Node merge(Node t1, Node t2) {
    if (t1 == null) {
        return t2;
    }
    if (t2 == null) {
        return t1;
    }
    if (t1.y > t2.y) {
        t1.right = merge(t1.right, t2);
        update(t1);
        return t1;
    } else {
        t2.left = merge(t1, t2.left);
        update(t2);
        return t2;
    }
}

static Node[] split(Node t, int x) {
    if (t == null) {
        return new Node[] {null, null};
    }
    if (x <= t.x) {
        Node[] tmp = split(t.left, x);
        t.left = tmp[1];
        update(t);
        tmp[1] = t;
        return tmp;
    } else {
        Node[] tmp = split(t.right, x);
        t.right = tmp[0];
        update(t);
        tmp[0] = t;
        return tmp;
    }
}
~~~~~~~~~~~~~~~~~~~~~~

[Декартово дерево по неявному ключу](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D0%BE_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE_%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE%D0%BC%D1%83_%D0%BA%D0%BB%D1%8E%D1%87%D1%83)
===================================

Несмотря на то, что оно так называется, оно делает совершенно не то же самое.

Обычное декартово дерево используется как _множество_: в него можно добавлять
элементы, удалять из него элементы, проверять, есть ли заданный элемент.

_Декартово дерево по неявному ключу_ же позволяет реализовать очень-очень-очень
продвинутый массив: обращение по индексу, изменение элемента, выпиливание
куска массива и вставка его в другое место, и многое другое.

Основное отличие заключается в функции `split`: теперь, вместо разделяющего
элемента она будет принимать количество, которое нужно отрезать от дерева:
`split`($T$, $x$) = $\langle T_1, T_2 \rangle$, где в дереве $T_1$ $x$
элементов. Реализация почти такая же, но при определении того, где проводить
разрез, нужно смотреть на количество элементов в левом поддереве, а не на значение
в корне разрезаемого.

[Реализация](/src/CartesianTree2.java)
----------

~~~~~~~~~~~~~java
static Random rnd = new Random(3);

static class Node {
    int x;
    int y;
    int cnt;

    Node left, right;

    Node(int x) {
        this.x = x;
        y = rnd.nextInt();
        cnt = 1;
        left = right = null;
    }
}

static int cnt(Node t) {
    return t == null ? 0 : t.cnt;
}

static void update(Node t) {
    if (t != null) {
        t.cnt = cnt(t.left) + 1 + cnt(t.right);
    }
}

static Node merge(Node t1, Node t2) {
    if (t1 == null) {
        return t2;
    }
    if (t2 == null) {
        return t1;
    }
    if (t1.y > t2.y) {
        t1.right = merge(t1.right, t2);
        update(t1);
        return t1;
    } else {
        t2.left = merge(t1, t2.left);
        update(t2);
        return t2;
    }
}

static Node[] split(Node t, int x) {
    if (t == null) {
        return new Node[] {null, null};
    }
    int left = cnt(t.left) + 1;
    if (x < left) {
        Node[] tmp = split(t.left, x);
        t.left = tmp[1];
        update(t);
        tmp[1] = t;
        return tmp;
    } else {
        Node[] tmp = split(t.right, x - left);
        t.right = tmp[0];
        update(t);
        tmp[0] = t;
        return tmp;
    }
}
~~~~~~~~~~~~~~~~~

Что ещё можно делать
--------------------

Во-первых, декартовым деревом по неявному ключу можно реализовать всё то же,
что реализовано деревом отрезков: чтобы посчитать сумму на отрезке, нужно
сделать два `split`-а, взять из центрального дерева нужную сумму, а потом
склеить деревья обратно.

Можно делать ещё, например, разворот подмассива. Для этого нужно в каждой
вершине хранить, нужно ли всё её поддерево развернуто. Далее, также, как и
в дереве отрезков с массовыми операциями, проталкивать этот флаг вниз.
При этом, если проталкивается вариант "да, надо развернуть всё поддерево",
то детей нужно ещё поменять местами.

Можно делать ещё кучу разных полезных и не очень фишек.

Персистентное дерево отрезков
=============================

Поставим такую задачу. Хочется, чтобы можно было делать в дереве отрезков
те же операции, что и раньше, но, при этом, чтобы можно было обращаться
ещё и к старым версиям: например, запрос вида "какая была сумма на таком-то
отрезке в дереве после $t$ запросов от начала". Раньше были только запросы
про предыдущее состояние.

Откажемся от идеи хранить дерево в массиве, в котором для $i$-й вершины
дети хранились в $2i$-й и $2i+1$-ых и будем просто хранить указатели на
левого и правого детей (как выше в декартовом дереве).

Наблюдение: если не перезаписывать никакую информацию в вершинах, то можно
будет хранить корни старых деревьев и, начиная запросы в них, отвечать.

Будем каждый раз, когда хочется что-то записать в какую-нибудь вершину,
создавать новую и возвращать её в качестве результата запроса.

(тут могла быть картинка, после которой всё становится понятно. 
но картинку мне рисовать совсем лень. если кого-то
интересует, могу нарисовать аналогичную на доске/бумажке в личном порядке)
