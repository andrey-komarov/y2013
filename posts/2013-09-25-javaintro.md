---
title: Введение в язык программирования Java
mathjax: on
---



Среды разработки
================

1. [IntelliJ IDEA](http://www.jetbrains.com/idea/)
2. [Eclipse](http://eclipse.org/)

В принципе, более-менее без разницы, какой из них пользоваться. Обе хорошие.
Раньше была проблема с тем, что на четверть- и полу- финалах есть только
Eclipse, так что, привыкнув к идее, можно было испытать проблемы. Сейчас,
возможно, проблема уже не актуальна, так как на компьютерах участников, начиная
с некоторого момента, установлена идея. (__TODO__ возможно, это всё неправда. 
Выяснить)

Язык
====

(почти) Всё - объект
--------------------

Понятие [кучи](http://ru.wikipedia.org/wiki/Куча_(нераспределённая_память)), 
того, что каждый объект нужно создать, того, что при [присваивании](http://ru.wikipedia.org/wiki/Java#.D0.94.D1.83.D0.B1.D0.BB.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.81.D1.81.D1.8B.D0.BB.D0.BE.D0.BA_.D0.B8_.D0.BA.D0.BB.D0.BE.D0.BD.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5) объект не
копируется, а копируется только ссылка.

Этот пример иллюстрирует последий тезис. `q` --- не новая точка, а та же самая,
что и `p`. При изменении внутренностей одной из них изменяется и вторая.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.java}
public class PointTest {
    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    public static void main(String[] args) {
        Point p = new Point(1, 2);
        Point q = p;
        q.x = 3;
        System.out.println(q.x + " " + p.x);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Каждый объект также может быть `null`-ом --- специальным нечто, что означает
отсутствие объекта.

Любая функция - метод
---------------------

Нет функций во внешней области видимости (в Паскале и C++) есть. В джаве любая
функция лежит в каком-то классе (например, `main` лежит в классе `PointTest`).

`public static void main(String[] args)`
---------------------------------------

Это точка входа в программу. Нужно это запомнить.

[static](http://ru.wikipedia.org/wiki/Java#.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B_.D0.B8_.D0.BF.D0.BE.D0.BB.D1.8F)
------

Вроде бы, на занятии я объяснил это не очень хорошо. Вкратце, суть в том, что
из всего `static` можно работать только с другими `static`.

[Примитивные типы](http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
----------------

То, что не объект. Всего восемь штук. На занятии я вас обманул. 
`char` не однобайтный (сам в шоке).

 Название       Что это                        Сколько это
----------    ------------                    -------------
 boolean       да или нет                      1 байт
 byte          -128..127                       1 байт
 short         $-2^{15}..2^{15}-1$             2 байта
 int           $-2^{31}..2^{31}-1$             4 байта
 long          $-2^{63}..2^{63}-1$             8 байт
 char          $0..2^{16}-1$                   2 байта
 float         вещественное число              4 байта
 double        вещественное число              8 байт

Коллекции
---------

Различные структуры данных.

* `[]` --- массив
* `ArrayList` --- аналог `std::vector`, [динамический массив](http://neerc.ifmo.ru/wiki/index.php?title=Саморасширяющийся_массив)
* `HashSet` --- множество на основе [хеш-таблицы](http://neerc.ifmo.ru/wiki/index.php?title=Хеш-таблица)
* `TreeSet` --- множество на основе двоичного дерева поиска
* `HashMap` --- `map` на основе хеш-таблицы
* `TreeMap` --- `map` на основе двоичного дерева поиска
* `ArrayDeque` --- [дек](http://ru.wikipedia.org/wiki/Двусвязная_очередь)

### Массивы ###

~~~~~~~~~~~~java
int[] a = new int[n];
int[][] b = new int[n][2 * n];
int[][] c = new int[n][];
for (int i = 0; i < n; i++) {
    c[i] = new int[i];
}
int[] d = b[0];
~~~~~~~~~~~~~~~~

Массивы. Нумеруются с нуля. Многомерный массив --- просто одномерный массив
массивов на один меньшей размерности. Можно получать длину `a.length`.

### `HashSet`, `HashMap` и откуда они берут функцию, которой хешировать ###

Чтобы использовать самописный класс в качестве ключа для хеш-таблицы, нужно
переопределить для этого класса методы `.hashCode()` и `.equals()`. Важно при
этом, чтобы соблюдался следующий инвариант: если есть два объекта `a` и `b`, то,
если `a.equals(b)`, то должно выполняться, что `a.hashCode() == b.hashCode()`,
то есть, хеши объектов, считающихся одинаковыми, должны совпадать.

~~~~~~~~~~~~~~~~~java
static class Point {
    int x, y, z;

    Point(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Point point = (Point) o;

        if (x != point.x) return false;
        if (y != point.y) return false;
        if (z != point.z) return false;

        return true;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash = hash * 31 + x;
        hash = hash * 31 + y;
        hash = hash * 31 + z;
        return hash;
    }
}
~~~~~~~~~~~~~~~~~~

[Аннотацией](http://ru.wikipedia.org/wiki/Аннотация_(Java)) `@Override` 
помечаются методы, реализация которых переопределяется от класса-потомка. В
данном случае, методы `.hashCode()` и `.equals()` определены в классе `Object`,
от которого наследуются все классы, если явно не указано обратного.

Стоит, также, отметить, что для функции хеширования, формально, подойдёт любая
функция, удовлетворяющая соотношению `.hashCode()` и `.equals()`. Например, такая

~~~~~~~~~~~~~~~~~~~java
// ...
    @Override
    int hashCode() {
        return 1;
    }
// ...
~~~~~~~~~~~~~~~~~~~~~~~~~~

Но не жалуйтесь потом на тормозящие коллекции.



### `TreeSet`, `TreeMap` и откуда они берут функцию сравнения на больше-меньше ###

Есть два источника функций сравнения --- _внутренний_ и _внешний_ компараторы.

#### Внутренний компаратор ####

Для использования внутреннего компаратора нужно реализовать метод `.compareTo`,
интерфейса `Comparable`:

~~~~~~~~~~~~~~~~java
static class MyInt implements Comparable<MyInt> {
    int a;

    MyInt(int a) {
        this.a = a;
    }

    @Override
    public int compareTo(MyInt i) {
        return Math.abs(a) - Math.abs(i.a);
    }
}
~~~~~~~~~~~~~~~~~

Метод `.compareTo` сравнивает тот объект, у которого вызвали этот метод с 
аргументом. Результатом является `0` в случае равенства объектов, что-нибудь
отрицательное, если объект, у которого вызывали метод, меньше аргумента и
что-нибудь положительное, если он больше.

Для корректной работы нужно, чтобы это было `.compareTo` было [отношением линейного
порядка](http://ru.wikipedia.org/wiki/Линейно_упорядоченное_множество) (рефлексивность,
антисимметричность, транзитивность).

Однако, возможностей _внутреннего_ компаратора может не хватить, когда речь идёт
об использовании одного и того же класса в качестве ключа в нескольких основанных
на деревьях (упорядоченных) структурах по-разному сравнивая их (например,
сортировать точки на плоскости в одном месте по координате $x$, а в другом ---
по координате $y$). Тут на помощь приходят внешние компараторы.

#### Внешний компаратор ####

Чтобы использовать внешний компаратор для класса `A`, нужно сделать какой-нибудь
класс, реализующий метод `compare` интерфейса `Comparator<A>`. 

~~~~~~~~~~~~~java
static class Cmp implements Comparator<MyInt> {
    @Override
    public int compare(MyInt i1, MyInt i2) {
        return i1.a - i2.a;
    }
}
~~~~~~~~~~~~~~~~~

Требования линейного порядка никто не отменял.

Для того, чтобы использовать внешний компаратор, нужно передать экземпляр
класса-компаратора в конструктор коллекции:

~~~~~~~~~~~~~~~~~~~~~java
TreeSet<MyInt> ts = new TreeSet<MyInt>(new Cmp());
~~~~~~~~~~~~~~~~~~~~~~~~~

Или, выделив `Cmp` явно:

~~~~~~~~~~~~~~~~~~~~~java
Cmp cmp = new Cmp();
TreeSet<MyInt> ts = new TreeSet<MyInt>(cmp);
~~~~~~~~~~~~~~~~~~~~~~~~~


_Boxing_ и _Unboxing_
---------------------

В связи с тем, что _примитивы_ (описанные выше) не являются полноправными
объектами, их нельзя использовать в коллекциях.

 Плохо             Хорошо
----------        ------------
`ArrayList<int>`    `ArrayList<Point>`
`Set<boolean>`      `Map<MyInt, ArrayList<MyInt>>`

Но все хотят класть самые стандартные типы в стандартные коллекции! Для этого
для всех примитивов сделали [типы-обёртки](http://en.wikipedia.org/wiki/Primitive_wrapper_class):

 Примитив      Обёртка
----------    ---------
 boolean       Boolean
 byte          Byte
 short         Short
 int           Integer
 long          Long
 char          Character
 float         Float
 double        Double

Почти всегда, тип-обёртка имеет такое же, как и примитив, имя, но с большой буквы.
Отличия в том, что это объекты, и, как следствие, их можно использовать везде,
где хочется использовать примитив, но нельзя (в основном, в качестве элементов
коллекций).

Жизнь --- весёлый карнавал:

~~~~~~~~~~~~~~~~~java
Integer a = 1;
Integer b = 1;
Integer c = 1000;
Integer d = 1000;
int e = 1000;
Integer f = new Integer(1);
Integer g = null;

System.out.println(a == b); // prints "true"
System.out.println(c == d); // prints "false"
System.out.println(c == e); // prints "true"
System.out.println(a == f); // prints "false"
System.out.println(c + d); // prints "2000"
System.out.println(c < d); // prints "false"
System.out.println(c.intValue() == d.intValue()); // prints "true"
~~~~~~~~~~~~~~~~~~~~~

А секрет в том, что [Java кеширует `Integer`-ы от -127 до 128](http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#valueOf(int)). Остальное логично.

Это всё, конечно, хорошо, но где реальные программы?..
------------------------------------------------------

Решим стандартную задачу --- суммирование двух чисел:

#### Первое приближение ####

~~~~~~~~~~~~~~~~~~~java
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;

public class Sum1 {

    void solve() {
        int a = in.nextInt();
        int b = in.nextInt();
        out.println(a + b);
    }

    static Scanner in;
    static PrintWriter out;

    public static void main(String[] args) throws FileNotFoundException {
        in = new Scanner(new File("input.txt"));
        out = new PrintWriter("output.txt");
        new Sum1().solve();
        out.close();
    }
}
~~~~~~~~~~~~~~~~~~~~~~~

Новые классы:

* `Scanner` --- чтение информации. В данном случае, из файла
    - _Warning_: `Scanner("input.txt") будет сканировать строку `"input.txt"` вместо
      одноимённого файла
    - Чтобы читать со стандартного ввода, надо написать `new Scanner(System.in)`
* `PrintWriter` --- вывод в файл
    - Это [буферизованный](http://ru.wikipedia.org/wiki/Буферизация_(информатика)) вывод.
      Это, в том числе, значит, что перед выходом из программы, `PrintWriter` нужно
      закрыть или сделать `.flush()`
    - Чтобы выводить на стандартный вывод, нужно написать `new PrintWriter(System.out)`

Недостатком `Scanner`-а является то, что его реализация основана на регулярных
выражениях, а значит, отличается ~~умом и сообразительностью~~ своей неторопливостью.
На больших входных данных можно запросто получить превышение лимита времени
исключительно из-за считывания с помощью `Scanner`-а. Решим эту проблему, написав
свою реализацию нужного нам подмножества `Scanner`-а.

#### Второе приближение ####

~~~~~~~~~~~~~~java
import java.io.*;
import java.util.StringTokenizer;

public class Sum2 {
    void solve() throws IOException {
        int a = in.nextInt();
        int b = in.nextInt();
        out.println(a + b);
    }

    static MyScanner in;
    static PrintWriter out;

    public static void main(String[] args) throws IOException {
        in = new MyScanner(new FileReader("input.txt"));
        out = new PrintWriter("output.txt");
        new Sum2().solve();
        out.close();
    }

    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(Reader r) {
            br = new BufferedReader(r);
        }

        String next() throws IOException {
            while (st == null || !st.hasMoreTokens()) {
                st = new StringTokenizer(br.readLine());
            }
            return st.nextToken();
        }

        int nextInt() throws IOException {
            return Integer.parseInt(next());
        }
    }
}
~~~~~~~~~~~~~~~~~~

Класс `MyScanner` можно в двух словах охарактеризовать как "будем читать файл
построчно, бить строку на слова, каждое слово парсить". Эта реализация оказывается
гораздо быстрее реализации, использующей `Scanner` (на этом примере это, конечно,
не критично, но при сотнях тысяч чисел на входе это становится критично). Для
того, чтобы читать со стандартного ввода, надо написать

~~~~~~~~java
in = new MyScanner(new InputStreamReader(System.in));
~~~~~~~~~~~~

Исключения
----------

Самые внимательные из вас заметили в программах выше строчки вида `throws IOException`.

#### Что такое исключение ####

Исключение --- реакция на то, что что-то пошло не так: обращение к методу у
`null`-а, несуществование файла там, где его ожидали увидеть, выход за границы
массива и т. д. После того,
как исключение вылетело, оно летит вверх по стеку, пока его кто-нибудь не поймает.
Если исключение никто не поймал, его ловит Java-машина и выводит на стандартный
вывод ошибок [stack trace](http://en.wikibooks.org/wiki/Java_Programming/Stack_trace),
по которому очень удобно смотреть, что именно пошло не так, в каких строчках
программы произошла ошибка, кто вызывал функцию, в которой что-то пошло не так.

#### _Проверяемые_ и _непроверяемые_ исключения ####

Все исключения делятся на _проверяемые_ и _непроверяемые_. Неформально говоря,
отличия в том, что непроверяемые исключения --- ошибки программиста (выход за
границы массива, обращение к чему-нибудь у `null`-а). Если оно вылетает, скорее
всего, где-то в программе есть ошибка. Проверяемые же исключения --- это, скорее,
ошибки окружающей системы: тот, кто писал программу, не виноват, что такого файла
не существует или что сетевое соединение разорвалось.

С точки зрения языка же, различие в том, что проверяемые исключение нужно либо
декларировать как `throws IOException`, что следует читать как "из этой функции
может вылететь IOException", либо ловить прямо здесь с помощью `try-catch`.

Код с занятия
=============

* [Containers.java](/src/Containers.java)
* [PointTest.java](/src/PointTest.java)
* [Sum1.java](/src/Sum1.java)
* [Sum2.java](/src/Sum2.java)
* [SumMany.java](/src/SumMany.java)
