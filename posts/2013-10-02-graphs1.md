---
title: Алгоритмы на графах
---

Как я и обещал, многие вещи рассказаны неформально во имя понимания происходящего.
Это нормально, если про какую-нибудь часть возникает вопрос "Ого, ничего себе!
А почему это так?".
Более формально и глубоко то же самое будет рассказано на настоящих парах.

Базовые определения
===================

Граф, ориентированный/неориентированный граф, взвешенный/невзвешенный.

Способы хранения графов
=======================

Пусть в графе $V$ вершин и $E$ рёбер.

Матрица смежности
-----------------

[Матрица смежности](http://ru.wikipedia.org/wiki/Матрица_смежности): таблица
$V \times V$, в $(i, j)$-й клетке которой стоит 0, если ребра $i \to j$ нет и
1, если ребро $i \to j$ есть. 

Преимущество: можно быстро проверять наличие конкретного ребра.

Недостаток: если рёбер мало, занимает много памяти.

Список рёбер
------------

Просто список из $E$ пар $\langle i, j \rangle$, из $i$ в $j$ есть ребро.

Недостаток: нельзя быстро проверить наличие конкретного ребра, нельзя быстро
пройтись по всем рёбрам.

Отсортированный список рёбер
----------------------------

Отсортируем список рёбер по первому элементу. В другом массиве для каждой вершины
будем хранить индекс в массиве рёбер, по которому начинаются рёбра из этой вершины.

Преимущества: мало памяти, можно перебирать рёбра из какой-нибудь вершины.

Недостатки: сложно, бессмысленно, вытеснено следущим способом.

Списки смежности
----------------

Для каждой вершины хранить список смежных с ней. Например, так:

~~~~~~~~~~~java
ArrayList<Integer>[] g = new ArrayList[n];
for (int i = 0; i < n; i++) {
    g[i] = new ArrayList<Integer>();
}
for (int i = 0; i < m; i++) {
    int a = in.nextInt();
    int b = in.nextInt();
    g[a].add(b);
}
~~~~~~~~~~~~~~~

Тогда в `g[v]` будет храниться список вершин, в которые есть рёбра из вершины `v`.

В большинстве случаев, это самый удобный способ хранить граф.

Небольшое отступление: [$O$-нотация](http://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое)
==================================

Программа работает за $O(f(n))$, если для любых входных данных она отработает
не более, чем за $c \cdot f(n)$ единиц времени, где $c$ --- какая-то (для каждого
алгоритма своя) константа.

Интуитивно, $O(f(n))$ можно читать как "не дольше, чем за $f(n)". Например,
сортировка пузырьком работает за $O(n^2)$. Но она работает и за $O(n^3)$ (это
не дольше реального времени работы).

Алгоритмы обхода невзвешенных графов
====================================

[Обход в ширину](http://neerc.ifmo.ru/wiki/index.php?title=Обход_в_ширину)
--------------

Поставим себе задачу --- найти в графе (неважно, ориентированном или нет)
длину кратчайшего пути от вершины $s$ до всех остальных.

Заведём массив `d`, в котором для каждой вершины будем хранить расстояние до неё
и массив `used`, в котором будем хранить, обработали ли мы уже эту вершину.
Ещё будем хранить очередь `q`, в которой будут вершины, которые ещё не обработаны.

Достаём вершину, смотрим на её соседей, если до них раньше не доходили,
добавляем их в очередь.


~~~~~~~~~~~~~~~java
boolean[] used = new boolean[n];
int[] dist = new int[n];
Queue<Integer> q = new ArrayDeque<Integer>();
q.add(s);
used[s] = true;
dist[s] = 0;

while (!q.isEmpty()) {
    int v = q.poll();
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v].get(i);
        if (!used[to]) {
            used[to] = true;
            dist[to] = dist[v] + 1;
            q.add(to);
        }
    }
}
~~~~~~~~~~~~~~~~~~~

### Ответ ###

После работы этого алгоритма, если в `used[v]` записано `true`, то в `dist[v]`
будет длина кратчайшего пути из вершины `s` в вершину `v`. Если в `used[v]`
записано `false`, то вершина `v` недостижима из `s`.

### Сам кратчайший путь ###

Если, помимо длины ответа, хочется восстановить ещё и сам путь как последовательность
вершин, можно, в тот момент, когда найдется новая вершина (`... if (!used[to]) { ...`),
нужно сохранить, из какой вершины мы в неё попали:

~~~~~~~~~~~~~~~java
boolean[] used = new boolean[n];
int[] dist = new int[n];
int[] prev = new int[n];
Arrays.fill(prev, -1);
Queue<Integer> q = new ArrayDeque<Integer>();
q.add(s);
used[s] = true;
dist[s] = 0;

while (!q.isEmpty()) {
    int v = q.poll();
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v].get(i);
        if (!used[to]) {
            used[to] = true;
            dist[to] = dist[v] + 1;
            prev[to] = v;
            q.add(to);
        }
    }
}
~~~~~~~~~~~~~~~~~~~

Тогда, рассматривая последовательность `v`, `prev[v]`, `prev[prev[v]]`, ....,
пока не упрёмся в `-1`, мы получим путь из `s` в `v`.

[Обход в глубину](http://neerc.ifmo.ru/wiki/index.php?title=Обход_в_глубину,_цвета_вершин)
-----------------

Обход в ширину обходит вершины в порядке увеличения расстояния до них.
Обход в глубину же обходит как-нибудь.

Возьмём вершину, переберём соседей, если в каком-то соседе не были --- запустимся
оттуда.

~~~~~~~~~~~~~~~java
void dfs(int v) {
    used[v] = true;
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v].get(i);
        if (!used[to]) {
            dfs(to);
        }
    }
}
~~~~~~~~~~~~~~~~~~~

Взвешенные графы
================

Решим задачу нахождения кратчайшего пути от одной из вершин взвешенного графа
до всех остальных. Будем пока считать, что, несмотря на то, что граф взвешенный,
веса рёбер неотрицательные.

[Алгоритм Форда-Беллмана](http://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Форда-Беллмана)
-----------------------

Обозначим за `d[v]` расстояние от стартовой вершины `s` до `v`, которое уже
посчиталось. Изначально `d[s] = 0`, `d[v] = `$+\infty$ (при $v \ne s$).

_Наблюдение_: так как отрицательных рёбер нет, то кратчайший путь не может
проходить по более, чем $V$ вершинам, так как, иначе, он проходит через какую-то
из вершин два раза и этот кусок пути от вершины до неё же можно безнаказанно
выбросить.

Будем несколько раз улучшать ответ по всем вершинам: перебираем все рёбра. 
Пусть в данный момент рассматривается ребро $v \to u$ веса $w$. Тогда, если
`d[u] > d[v] + w`, то расстояние до `u` можно улучшить, дойдя сначала до `v`, а
затем пройдя по ребру $v \to u$ в `u`.

Улучшив ответ вдоль всех рёбер $V$ раз, получим окончательный ответ.

Код с занятия
=============

* [BFS.java](/src/BFS.java)
* [DFS.java](/src/DFS.java)
* [DFS2.java](/src/DFS2.java)
