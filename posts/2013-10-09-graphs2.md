---
title: Алгоритмы на графах (продолжение)
mathjax: on
---

[Куча](http://neerc.ifmo.ru/wiki/index.php?title=Двоичная_куча)
================

Приоритетная очередь
--------------------

Назовём _приоритетной очередью_ нечто, что умеет делать следующий набор 
операций:

* `add` --- добавить элемент
* `getMin` --- получить минимальный элемент
* `extractMin` --- выбросить минимальный элемент

Почти полное двоичное дерево
----------------------------

Назовём _почти полным_ двоичным деревом двоичное дерево, у которого неполным
может быть только конец последнего слоя.

Занумеруем вершины дерева с нуля сверху вниз, слева направо. Замечаем интересную
закономерность: дети вершины $i$ имеют номера $2i + 1$ и $2i + 2$. Поэтому,
можно явно это дерево не строить, а только представлять, что оно есть.

Двоичная куча
-------------

_Двоичная куча_ --- почти полное двоичное дерево такое, что каждый ребёнок каждой
вершины не меньше её самой:

* `h[i] <= h[2 * i + 1]`
* `h[i] <= h[2 * i + 2]`

Покажем, что двоичная куча --- очередь с приоритетами

### Добавление ###

Добавим новый элемент на первое незанятое место в последнем слое дерева (если
он кончился, создадим новый). Тогда инвариант кучи мог сломаться только в
предке добавленной вершины. Если сломался, его можно починить, поменяв добавленную
вершину с её предком. После этого мог сломаться только предок предка добавленной,
починим, и т. д.

Итого, вся процедура вставки работает за время, пропорциональное высоте дерева,
а высота дерева --- $O(\log n)$.

### Взятие минимума ###

Он на вершине (`h[0]`).

### Удаление минимума ###

Из двоичной кучи, на самом деле, можно удалять не только минимум, но и любой
другой произвольный элемент (нужно только знать, где он в ней лежит. например, 
минимум лежит в `0` ячейке).

Для того, чтобы удалить какой-то элемент:

1. Поменяем его с последним в последнем слое.
2. Удалим последний в последнем слое (просто уменьшим размер кучи).
3. Починим то, что сломалось там, куда пришёл бывший последним элемент.

Для выполнения последнего пункта посмотрим, правда ли, что оба ребёнка
рассматриваемого элемента не меньше его. Если какой-то из них (или оба)
меньше --- то поменяем с ним, повторим этот процесс для нового ребёнка.

Работает так же, как и добавление --- за $O(\log n)$.

Кратчайшие пути во взвешенных графах (продолжение)
================

[Алгоритм Дейкстры](http://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Дейкстры)
-----------------

Проведём аналогию между (ещё не озвученным) алгоритмом Дейкстры и обходом
в ширину. В обходе в ширину была очередь, в которую попадали элементы по
возрастанию расстояния от начальной вершины. Из очереди извлекался очередной
элемент, рассматривались рёбра из него и для концов рёбер, возможно, улучшался
ответ. Здесь будет происходить примерно то же самое. Мешает лишь то, что
у рёбер есть вес (раньше он для всех рёбер был равен 1).

Как и в алгоритме Форда-Беллмана, предположим, что все рёбра имеют неотрицательный
вес.

Создадим массив `d`, в котором будут храниться расстояния от вершины `s`, 
очередь с приоритетами `q`, в которой будут храниться вершины, которые ещё
нужно рассмотреть (аналогично обходу в ширину). Вершины в очереди должны быть
отсортированы по увеличению расстояния от `s`: чем меньше расстояние, тем
раньше достаём вершину из очереди. 

> __Внимание__: на занятии я вас немного обманул, сказав, что, действительно, можно 
> хранить в `TreeSet`-е просто числа и сравнивать их по увеличению-уменьшению расстояния.
> Это не совсем верно. В `TreeSet`-е (как и в любом `Set`-е) хранятся уникальные
> элементы. Поэтому, если есть две вершины с одинаковым расстоянием до них, в
> `Set`-е будет только одна из них. Это не то, что ожидается.
>
> Поэтому, есть варианты того, что делать:
> 
> * Хранить в `PriorityQueue` числа (в `PriorityQueue` дубликаты разрешены).
> * Хранить в `Set`-е числа, но при равенстве расстояний сравнивать сами числа.
> * Хранить в `Set`-е пары $\langle расстояние, вершина \rangle$.
 
После чего, смотрим на соседей вершины, улучшаем расстояние до них, кладём новые
в очередь.

~~~~~~~~~~~~~~java
final int[] d = new int[n];
Arrays.fill(d, INF);
d[s] = 0;
TreeSet<Integer> q = new TreeSet<>(new Comparator<Integer>() {
    @Override
    public int compare(Integer v1, Integer v2) {
        if (d[v1] != d[v2]) {
            return d[v1] - d[v2];
        }
        return v1 - v2;
    }
});
q.add(s);
while (!q.isEmpty()) {
    int v = q.pollFirst();
    for (int i = 0; i < g[v].size(); i++) {
        Edge e = g[v].get(i);
        if (d[e.to] > d[v] + e.w) {
            q.remove(e.to);
            d[e.to] = d[v] + e.w;
            q.add(e.to);
        }
    }
}
~~~~~~~~~~~~~~~~~~

Сложность алгоритма --- $O(E \cdot \log V)$.

> __Внимание__: английское написание фамилии Дейкстра --- Dijkstra.

[Алгоритм Флойда](http://neerc.ifmo.ru/wiki/index.php?title=Алгоритм_Флойда)
-----------------

Алгоритмы Дейкстры и Форда-Беллмана использовались для того, чтобы найти
кратчайшее расстояние от одной заданной вершины до остальных. В алгоритме Флойда
расстояние ищется сразу от каждой вершины до каждой. Одним из преимуществ перед
$V$ запусками алгоритма Дейкстры (по разу из каждой вершины) является то, что
алгоритм Флойда гораздо проще пишется.

Обозначим за `d[k][i][j]` длину кратчайшего пути от вершины `i` до вершины `j`,
проходящего только через вершины с _номерами_, не превышающими `k`.

Тогда сразу можно сказать, что `d[0][i][j]`, в зависимости от того, есть ли в 
графе ребро из `i` в `j`, равно либо весу этого ребра, либо $+\infty$.

Научимся считать `d[k][i][j]`. Кратчайший путь, соответствующий `d[k][i][j]`
либо проходит через вершину `k`, либо не проходит. В первом случае, он равен
`d[k-1][i][k] + d[k-1][k][j]`, а во втором --- `d[k-1][i][j]`. Итого, получаем,
что `d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k] + d[k-1][k][j]`.

Заметим, что, по определению `d[k][i][j]`, `d[k][i][j]` $\ge$ `d[k+1][i][j]`.
Поэтому, первое измерение можно не хранить, а сразу всё считать в оставшиеся два.

~~~~~~~~~~~~java
for (int k = 0; k < n; k++) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            a[i][j] = min(a[i][j], a[i][k] + a[k][j]);
        }
    }
}
~~~~~~~~~~~~~~~~

[Система непересекающихся множеств](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B0_.D0.BD.D0.B5.D0.BF.D0.B5.D1.80.D0.B5.D1.81.D0.B5.D0.BA.D0.B0.D1.8E.D1.89.D0.B8.D1.85.D1.81.D1.8F_.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D1.81.D1.82.D0.B2)
===================================

Мы хотим заполучить нечто, что умеет делать следующие операции:

* `get(v)` --- получить _цвет_ элемента с номером `v`.
* `union(v1, v2)` --- объединить множества, соответствующие элементам с номерами `v1` и `v2`

Изначально все элементы в разных множествах, имеют разный цвет.
_Цвет_ --- нечто, что характеризует множество, в котором лежит элемент.
Если два элемента лежат в одном и том же множестве, у них один и тот же цвет.

[Реализация массивом](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_(%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)#.D0.A1_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D1.8C.D1.8E_.D0.BC.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D0.B0)
-------------------

В массиве будем хранить цвет для каждой вершины, при объединении перекрашивать.

[Реализация списком](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_(%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)#.D0.A1_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D1.8C.D1.8E_.D1.81.D0.BF.D0.B8.D1.81.D0.BA.D0.B0)
-------------------

Будем для каждого цвета хранить список элементов этого цвета. Также, для каждого
элемента будем хранить его цвет.

Перекрашивание --- пробежаться по одному из списков и перекрасить все вершины из
него.

[Оптимизация: пробегаться по меньшему списку](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_(%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B8_%D1%81_%D0%B2%D0%B5%D1%81%D0%BE%D0%B2%D0%BE%D0%B9_%D1%8D%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%BE%D0%B9))
--------------------

Если для каждого списка хранить его длину и пробегаться по меньшему из них, то
среднее время на перекрашивание будет равно $O(\log n)$. Это можно доказать
опираясь на то, что элемент перекрашивается только когда находится в меньшем
списке, после перекрашивания меньший список увеличивается хотя бы в два раза.

[Реализация ~~идёт~~ лесом](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C(%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BB%D0%B5%D1%81%D0%B0_%D0%BA%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D1%8B%D1%85_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D0%B5%D0%B2))
---------------------------

Рассмотрим набор подвешенных деревьев. Если два элемента лежат в одном множестве,
то они лежат в одном дереве. Цветом будет корень дерева.

Для каждой вершины будем хранить её предка в дереве. Для корня предком будет сам
корень.

Теперь, чтобы определить цвет вершины, нужно подняться до корня и вернуть его
номер. А чтобы объединить два дерева, нужно предком корня одного из них сделать
корень другого.

Оптимизация --- ранговая эвристика
----------------------------------

Аналогично склеиванию списков пробегом по меньшему из них. Работает за тот же
самый $O(\log n)$.

Оптимизация --- сжатие путей
----------------------------

Можно каждой вершине, встреченной на пути во время выполнения запроса `get`,
ставить предком непосредственно ответ. Это позволит "срезать" путь этой и другим
вершинам. Срезает до такой степени, что остаётся $O(\log n)$ на запрос.

Реализация
----------

~~~~~~~~~~~~~~java
public class DSU {
    int[] p;
    Random rnd;

    DSU(int n) {
        p = new int[n];
        for (int i = 0; i < n; i++) {
            p[i] = i;
        }
        rnd = new Random(3);
    }

    int get(int v) {
        return p[v] == v ? v : (p[v] = get(p[v]));
    }

    void union(int v1, int v2) {
        v1 = get(v1);
        v2 = get(v2);
        if (v1 == v2) {
            return;
        }
        if (rnd.nextBoolean()) {
            p[v1] = v2;
        } else {
            p[v2] = v1;
        }
    }
}
~~~~~~~~~~~~~~~~~~

Это реализация без ранговой эвристики. Но и она на практике работает очень быстро.

Код
===

* [Dijkstra.java](/src/Dijkstra.java)
* [DSU.java](/src/DSU.java)
