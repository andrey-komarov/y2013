---
title: Поиск подстроки в строке
mathjax: on
---

[Алгоритм Кнута-Морриса-Пратта](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D0%BD%D1%83%D1%82%D0%B0-%D0%9C%D0%BE%D1%80%D1%80%D0%B8%D1%81%D0%B0-%D0%9F%D1%80%D0%B0%D1%82%D1%82%D0%B0)
================================

[Префикс-функция](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
-----------------

Префикс-функция строки $s$ --- $\pi[i] = \arg\max\limits_{k \in [0; i)} s[:k] = s[i-k:i]$

(тут тоже нужны картиночки :( )

Пусть мы уже посчитали префикс-функцию для элементов от 0-го до $m-1$-го и хотим
посчитать для $i$-го. Если $s[\pi[m-1]] = s[m]$ (тут явно косяки с $\pm 1$),
то $\pi[m] = \pi[m-1] + 1$. Иначе, нужно смотреть на $\pi[\pi[m-1]]$, и так
далее.

Не умею я так объяснять префикс-функцию, лучше почитайте по ссылочке.

[$z$-функция](http://neerc.ifmo.ru/wiki/index.php?title=Z-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
=============

То же самое для $z$-функции. (Совсем разленился, да)

[Хеширование](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8_%D0%B2_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B5_%D1%81_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC_%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F._%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A0%D0%B0%D0%B1%D0%B8%D0%BD%D0%B0-%D0%9A%D0%B0%D1%80%D0%BF%D0%B0)
============

Вот тут уже можно рассказать получше, чем про {префикс,z}-функции.

Зафиксируем числа $M$ и $X$ (_модуль_ и _основание_ хеша).

Назовём _полиномиальным_ хешом строки $s$: $h(s) = (\sum\limits_{i=0}^{n-1} X^{n-i-1} s_i) \mod M$

Строки $s_1 \ne s_2$: $h(s_1) = h(s_2)$ назовём _коллизией_.

Некоторое время будем жить в идеальном мире и считать, что коллизий не бывает
(очевидно, в реальном мире это не так. Строк больше $M$, принцип Дирихле, все
дела).

Хотим решать задачу поиска вхождений строки $t$ в строке $s$. Если мы сможем
посчитать хеши всех подстрок строки $s$ длиной $|t|$, и выбрать те, которые
равны $h(t)$, то задача будет решена. Самый тупой способ даст счёт хеша каждой
нужной подстроки за $O(|t|)$, итого, за $O(|s| \cdot |t|)$.

Научимся из хеша $h(s[i:i+t])$ получать $h(s[i+1:i+t+1])$.

$h(s[i:i+|t|]) = (X^{|t|-1}s_i + X^{|t|-2}s_{i+1} + \ldots + Xs_{i+|t|-2} + s_{i+|t|-1}) \mod M$

$h(s[i+1:i+|t|+1]) = (X^{|t|-1}s_{i+1} + X^{|t|-2}s_{i+2} + \ldots + Xs_{i+|t|-1} + s_{i+|t|}) \mod M$

$h(s[i+1:i+|t|+1]) = ((h(s[i:i+|t|]) - X^{|t|-1}s_i) \cdot X + s_{i+|t|}) \mod M$

Ура, научились пересчитывать хеш для следующей подстроки за $O(1)$.
Итоговая сложность: $O(|s| + |t|).

Хеши подстрок
-------------

Рассмотрим трюк, позволяющий за $O(1)$ получить хеш любой подстроки.

Посчитаем $pref[i] = h(s[:i]) = \sum\limits_{j=0}^{i-1} X^{i-j-1}s_j$.

Тогда несложно выяснить, что $h(s[left:right]) = pref[right] - pref[left] * X^{right-left}$,
что можно посчитать за $O(1)$, предпочсчитав $X^i$.

Как выбрать $X$ и $M$
---------------------

###На первый взгляд хорошая идея

Давайте считать $M = 2^64$. Тогда можно избавиться от дорогостоящей операции
взятия по модулю (само посчитается по модулю $2^64$).

Но, увы, существуют строки, которые для любого $X$ дают хеш 0, а, следовательно,
можно сделать коллизии, от которых будут страдать все.

###Как выбрать $X$?

Какое-нибудь нечётное число, большее любого символа строки.

###Как выбрать $M$?

Какое-нибудь большое нечётное число, взаимно простое с $X$.

###Что делать, если коллизии?

Посчитать по двум модулям: $M_1$ и $M_2$.
