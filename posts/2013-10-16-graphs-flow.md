---
title: Алгоритмы на графах: Потоки
---

Минимальные остовные деревья
===========================

[Алгоритм Краскала](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)
-------------------

На прошлом занятии был рассмотрен алгоритм построения остовного дерева в
невзвешенном графе: создаём [СНМ](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B0_.D0.BD.D0.B5.D0.BF.D0.B5.D1.80.D0.B5.D1.81.D0.B5.D0.BA.D0.B0.D1.8E.D1.89.D0.B8.D1.85.D1.81.D1.8F_.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D1.81.D1.82.D0.B2), перебираем рёбра, если ребром
соединяются элементы разных множеств, то добавляем его, объединяем множеста.

Алгоритм Краскала делает примерно то же самое. Хотим построить _минимальное_
остовное дерево. Отсортируем рёбра по возрастанию стоимости, пробежимся по ним
в этом порядке, добавляя в ответ те, которые соединяют разные множества в СНМ.
Результат будет минимальным остовным деревом.

[Алгоритм Прима](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9F%D1%80%D0%B8%D0%BC%D0%B0)
----------------

Алгоритм Краскала строил дерево, добавляя рёбра в произвольных местах графа.

Алгоритм Прима будет строить его, как бы "разрастая" остовное дерево от
какой-то начальной вершины. Будем хранить множество вершин, которые уже в
остовном дереве, и поддерживать для каждой вершины не из этого множества 
вес минимального ребра, ведущего в это множество.

После этого, будем каждый раз выбирать вершину, в которую идёт минимальное
ребро, добавлять её к ответу и пересчитывать минимальные расстояния

### Реализация

Граф хранится матрицей смежности, `-1`, если ребра нет. Считается, что граф
связный.

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = a[best][j];
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Сравние это с алгоритмом Дейкстры:

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = d[best] + a[best][j]; // Смотреть сюда. Обещанная одна строчка
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Кто лучше?
----------

Алгоритм Краскала работает за $O(E \cdot \log V)$ --- отсортировать рёбра,
пройтись по ним и добавлять в СНМ.

Рассмотренная реализация алгоритма Прима работает за $O(V^2)$.

Поэтому, оба алгоритма имеют право на жизнь: на графах, где рёбер много, лучше 
работает алгоритм Прима, а где мало --- Краскала.

Следует, однако, признать, что можно, аналогично алгоритму Дейкстры, реализовать
алгоритм Прима за те же самые $O(E \cdot \log V)$, но реализация будет сложнее,
чем реализация алгоритма Краскала.


[Потоки](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B0_.D0.BE_.D0.BC.D0.B0.D0.BA.D1.81.D0.B8.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.BC_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B5)
======

[Постановка задачи](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%B5%D1%82%D0%B8,_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
-------------------

Рассмотрим следующую задачу. Есть трубопровод (граф), и две выделенные 
вершины --- исток и сток. В истоке стоит кран, из которого может течь сколько
угодно воды, а в стоке --- слив, в который может стекать сколько угодно воды.
Через каждую трубу может протечь не больше $c_i$ литров воды в час. Сколько
может максимум протечь из истока в сток?

### [Остаточная сеть](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D1%8E%D1%89%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C,_%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D1%8E%D1%89%D0%B8%D0%B9_%D0%BF%D1%83%D1%82%D1%8C)

Если по какому-то ребру что-то течёт, то это можно _отменить_. Символизировать
это будет обратное ребро, по которому можно пустить столько, сколько течёт по
прямому.

### [Теорема Форда-Фалкерсона](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0)

Поток максимальный тогда и только тогда, когда в остаточной сети нет пути по
рёбрам ненулевой пропускной способности из истока в сток.

### [Алгоритм Форда-Фалкерсона](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0,_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83)

1. Найти дополняющий путь
2. Увеличить поток вдоль него

Повторять, пока дополняющий путь находится. 

Искать дополняющий путь можно хоть как. Например, обходом в глубину. Правда,
тогда алгоритм будет работать [медленно](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0,_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BC.D0.B5.D0.B4.D0.BB.D0.B5.D0.BD.D0.BD.D0.BE.D0.B9_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D0.B0.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D0.B0_.D0.A4.D0.BE.D1.80.D0.B4.D0.B0-.D0.A4.D0.B0.D0.BB.D0.BA.D0.B5.D1.80.D1.81.D0.BE.D0.BD.D0.B0_.D1.81_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA.D0.B0_.D0.B2_.D0.B3.D0.BB.D1.83.D0.B1.D0.B8.D0.BD.D1.83_.D0.BF.D0.BE_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D1.8E_.D1.81_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B5.D0.B9.2C_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D1.83.D1.8E.D1.89.D0.B5.D0.B9_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D0.B2_.D1.88.D0.B8.D1.80.D0.B8.D0.BD.D1.83) (за
$O(E \cdot |f|)$ в случае вещественных (настоящие $\mathbb{R}$) пропускных
способностей так и вообще [не работает](http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0_%E2%80%94_%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BD.D0.B5_.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B3.D0.BE.D1.81.D1.8F_.D0.B0.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D0.B0).

### [Алгоритм Эдмонса-Карпа](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%AD%D0%B4%D0%BC%D0%BE%D0%BD%D0%B4%D1%81%D0%B0-%D0%9A%D0%B0%D1%80%D0%BF%D0%B0)

А можно искать дополняющие пути обходом в ширину. Тогда будет работать за время,
не зависящее от размера потока (за $O(E^2 V)$).

### [Масштабирование потока](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)

Идея --- звучит логично, что выгодно искать сначала большие потоки, а потом ---
маленькие. 

Пусть пропускные способности целые и не превышают $2^h = U$. Алгоритм состоит из
$h$ фаз. В очередной фазе в графе (остаточной сети) остаются только рёбра,
не меньшие $2^{h-t}$, где $t$ --- номер фазы: сначала остаются только рёбра с
пропускной способностью $U$, затем от $U / 2$, $U / 4$, ..., 4, 2, 1.

На последней фазе алгоритм вырождается в алгоритм Форда-Фалкерсона, следовательно,
корректен.

Время работы --- $O(E^2 \cdot h)$.

### [Алгоритм Диница](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D1%85%D0%B5%D0%BC%D0%B0_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_%D0%94%D0%B8%D0%BD%D0%B8%D1%86%D0%B0)

Введём понятие _блокирующего потока_.

Разобъём остаточную сеть на _слои_ по кратчайшему расстоянию по рёбрам.
Мысленно удалим все рёбра, которые ведут не в следующий слой. Максимальный
поток в оставшемся графе --- _блокирующий поток_.

Будем искать блокирующий поток, перестраивать слои, снова искать блокирующий
поток итд.

Сложность --- $O(V^2 \cdot E)$. На практике этот алгоритм показывает весьма
хорошую скорость работы. Весьма поучительна его реализация.

ТУТ РЕАЛИЗАЦИЯ

Потоки минимальной стоимости
============================

TBD
