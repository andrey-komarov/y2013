---
title: Алгоритмы на графах: Потоки
mathjax: on
---

Минимальные остовные деревья
===========================

[Алгоритм Краскала](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)
-------------------

На прошлом занятии был рассмотрен алгоритм построения остовного дерева в
невзвешенном графе: создаём [СНМ](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B0_.D0.BD.D0.B5.D0.BF.D0.B5.D1.80.D0.B5.D1.81.D0.B5.D0.BA.D0.B0.D1.8E.D1.89.D0.B8.D1.85.D1.81.D1.8F_.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D1.81.D1.82.D0.B2), перебираем рёбра, если ребром
соединяются элементы разных множеств, то добавляем его, объединяем множеста.

Алгоритм Краскала делает примерно то же самое. Хотим построить _минимальное_
остовное дерево. Отсортируем рёбра по возрастанию стоимости, пробежимся по ним
в этом порядке, добавляя в ответ те, которые соединяют разные множества в СНМ.
Результат будет минимальным остовным деревом.

[Алгоритм Прима](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9F%D1%80%D0%B8%D0%BC%D0%B0)
----------------

Алгоритм Краскала строил дерево, добавляя рёбра в произвольных местах графа.

Алгоритм Прима будет строить его, как бы "разрастая" остовное дерево от
какой-то начальной вершины. Будем хранить множество вершин, которые уже в
остовном дереве, и поддерживать для каждой вершины не из этого множества 
вес минимального ребра, ведущего в это множество.

После этого, будем каждый раз выбирать вершину, в которую идёт минимальное
ребро, добавлять её к ответу и пересчитывать минимальные расстояния

### Реализация

Граф хранится матрицей смежности, `-1`, если ребра нет. Считается, что граф
связный.

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = a[best][j];
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Сравние это с алгоритмом Дейкстры:

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = d[best] + a[best][j]; // Смотреть сюда. Обещанная одна строчка
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Кто лучше?
----------

Алгоритм Краскала работает за $O(E \cdot \log V)$ --- отсортировать рёбра,
пройтись по ним и добавлять в СНМ.

Рассмотренная реализация алгоритма Прима работает за $O(V^2)$.

Поэтому, оба алгоритма имеют право на жизнь: на графах, где рёбер много, лучше 
работает алгоритм Прима, а где мало --- Краскала.

Следует, однако, признать, что можно, аналогично алгоритму Дейкстры, реализовать
алгоритм Прима за те же самые $O(E \cdot \log V)$, но реализация будет сложнее,
чем реализация алгоритма Краскала.


[Потоки](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B0_.D0.BE_.D0.BC.D0.B0.D0.BA.D1.81.D0.B8.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.BC_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B5)
======

[Постановка задачи](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81%D0%B5%D1%82%D0%B8,_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)
-------------------

Рассмотрим следующую задачу. Есть трубопровод (граф), и две выделенные 
вершины --- исток и сток. В истоке стоит кран, из которого может течь сколько
угодно воды, а в стоке --- слив, в который может стекать сколько угодно воды.
Через каждую трубу может протечь не больше $c_i$ литров воды в час. Сколько
может максимум протечь из истока в сток?

### [Остаточная сеть](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D1%8E%D1%89%D0%B0%D1%8F_%D1%81%D0%B5%D1%82%D1%8C,_%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D1%8F%D1%8E%D1%89%D0%B8%D0%B9_%D0%BF%D1%83%D1%82%D1%8C)

Если по какому-то ребру что-то течёт, то это можно _отменить_. Символизировать
это будет обратное ребро, по которому можно пустить столько, сколько течёт по
прямому.

### [Теорема Форда-Фалкерсона](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0)

Поток максимальный тогда и только тогда, когда в остаточной сети нет пути по
рёбрам ненулевой пропускной способности из истока в сток.

### [Алгоритм Форда-Фалкерсона](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0,_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83)

1. Найти дополняющий путь
2. Увеличить поток вдоль него

Повторять, пока дополняющий путь находится. 

Искать дополняющий путь можно хоть как. Например, обходом в глубину. Правда,
тогда алгоритм будет работать [медленно](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0-%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0,_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BC.D0.B5.D0.B4.D0.BB.D0.B5.D0.BD.D0.BD.D0.BE.D0.B9_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D0.B0.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D0.B0_.D0.A4.D0.BE.D1.80.D0.B4.D0.B0-.D0.A4.D0.B0.D0.BB.D0.BA.D0.B5.D1.80.D1.81.D0.BE.D0.BD.D0.B0_.D1.81_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA.D0.B0_.D0.B2_.D0.B3.D0.BB.D1.83.D0.B1.D0.B8.D0.BD.D1.83_.D0.BF.D0.BE_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D1.8E_.D1.81_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B5.D0.B9.2C_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D1.83.D1.8E.D1.89.D0.B5.D0.B9_.D0.BF.D0.BE.D0.B8.D1.81.D0.BA_.D0.B2_.D1.88.D0.B8.D1.80.D0.B8.D0.BD.D1.83) (за
$O(E \cdot |f|)$ в случае вещественных (настоящие $\mathbb{R}$) пропускных
способностей так и вообще [не работает](http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%A4%D0%BE%D1%80%D0%B4%D0%B0_%E2%80%94_%D0%A4%D0%B0%D0%BB%D0%BA%D0%B5%D1%80%D1%81%D0%BE%D0%BD%D0%B0#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BD.D0.B5_.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B3.D0.BE.D1.81.D1.8F_.D0.B0.D0.BB.D0.B3.D0.BE.D1.80.D0.B8.D1.82.D0.BC.D0.B0).

### [Алгоритм Эдмонса-Карпа](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%AD%D0%B4%D0%BC%D0%BE%D0%BD%D0%B4%D1%81%D0%B0-%D0%9A%D0%B0%D1%80%D0%BF%D0%B0)

А можно искать дополняющие пути обходом в ширину. Тогда будет работать за время,
не зависящее от размера потока (за $O(E^2 V)$).

### [Масштабирование потока](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B0)

Идея --- звучит логично, что выгодно искать сначала большие потоки, а потом ---
маленькие. 

Пусть пропускные способности целые и не превышают $2^h = U$. Алгоритм состоит из
$h$ фаз. В очередной фазе в графе (остаточной сети) остаются только рёбра,
не меньшие $2^{h-t}$, где $t$ --- номер фазы: сначала остаются только рёбра с
пропускной способностью $U$, затем от $U / 2$, $U / 4$, ..., 4, 2, 1.

На последней фазе алгоритм вырождается в алгоритм Форда-Фалкерсона, следовательно,
корректен.

Время работы --- $O(E^2 \cdot h)$.

### [Алгоритм Диница](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D1%85%D0%B5%D0%BC%D0%B0_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0_%D0%94%D0%B8%D0%BD%D0%B8%D1%86%D0%B0)

Введём понятие _блокирующего потока_.

Разобъём остаточную сеть на _слои_ по кратчайшему расстоянию по рёбрам.
Мысленно удалим все рёбра, которые ведут не в следующий слой. Максимальный
поток в оставшемся графе --- _блокирующий поток_.

Будем искать блокирующий поток, перестраивать слои, снова искать блокирующий
поток итд.

Сложность --- $O(V^2 \cdot E)$. На практике этот алгоритм показывает весьма
хорошую скорость работы. Весьма поучительна его реализация.

#### Реализация

~~~~~~~~~~~~~~~~java
static class Graph {
    /* Ребро. remain --- сколько ещё можно по нему пустить
     * rev --- обратное ребро. У каждого ребра есть обратное,
     * пуск потока по которому соответствует отмене потока
     * через прямое
     */
    static class Edge {
        int to;
        int remain;
        Edge rev;

        Edge(int to, int remain) {
            this.to = to;
            this.remain = remain;
        }
    }

    int n;
    ArrayList<Edge>[] edges;

    /* Слой, в котором находится вершина. Используется для поиска блокирующего
        потока
     */
    int[] layer;

    /* Массив "посещена ли вершина обходом в глубину, ищущим дополняющий путь"
     *
     * Выглядит он так странно потому, что хочется его быстро очищать
     * читай used[v] == true, если used[v] == version.
     * Теперь для очистки нужно всего лишь сделать version++. Тогда все
     * автоматически сбросятся в false
     */
    int[] used;
    int version;

    /* Тут магия.
    *
    * start[v] - номер первого ребра, выходящего из вершины v, которое
    * осмысленно рассматривать. При рассмотрении рёбер
    * edges[v][0..start[v]) нельзя найти дополняющий путей.
    * */
    int[] start;

    Graph(int n) {
        this.n = n;
        edges = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            edges[i] = new ArrayList<>();
        }

        used = new int[n];
        version = 1;

        start = new int[n];
    }

    /* Добавить ребро from->to пропускной способности cap
     * При этом, добавляется обратное ребро, по которому можно
     * пустить ещё 0 ("можно отменить 0 потока")
     */
    void addEdge(int from, int to, int cap) {
        Edge e = new Edge(to, cap);
        Edge e2 = new Edge(from, 0);
        e.rev = e2;
        e2.rev = e;
        edges[from].add(e);
        edges[to].add(e2);
    }

    /* "Есть ли вообще путь s ~> t?"
     *
     * А заодно, перенумеровать слои
     */
    boolean bfs(int s, int t) {
        layer = new int[n];
        Arrays.fill(layer, -1);
        Queue<Integer> q = new ArrayDeque<>();
        q.add(s);
        layer[s] = 0;
        while (!q.isEmpty()) {
            int v = q.poll();
            for (int i = 0; i < edges[v].size(); i++) {
                Edge e = edges[v].get(i);
                if (e.remain == 0) {
                    continue;
                }
                if (layer[e.to] == -1) {
                    layer[e.to] = layer[v] + 1;
                    q.add(e.to);
                }
            }
        }
        return layer[t] != -1;
    }

    /* "Найти дополняющий путь v ~> t и обновить поток по нему, с учётом того,
     * что до v дотекает всего min потока. Вернуть, сколько потока добавилось"
     */
    int dfs(int v, int t, int min) {
        // Нашли
        if (v == t) {
            return min;
        }
        used[v] = version;
        /* Обещанная магия. Начинаем рассматривать рёбра не с первого, а с
         * первого осмысленного.
         *
         * Если при дальнейшем рассмотрении нашёлся дополняющий путь, то
         * start[v] не двигается (текущее ребро всё ещё осмысленно).
         * Если же не нашёлся, то и до следующего пересчёта слоёв не найдётся,
         * и его можно выкинуть.
         */
        for (; start[v] < edges[v].size(); start[v]++) {
            Edge e = edges[v].get(start[v]);
            if (e.remain == 0 || layer[e.to] != layer[v] + 1) {
                continue;
            }
            int add;
            if ((add = dfs(e.to, t, Math.min(min, e.remain))) != 0) {
                // Пускаем поток. add - сколько добавилось.
                e.remain -= add;
                // Столько же можно отменить.
                e.rev.remain += add;
                return add;
            }
        }
        return 0;
    }

    long maxFlow(int s, int t) {
        long flow = 0;
        // Пока вообще есть путь...
        while (bfs(s, t)) {
            long add;
            version++;
            Arrays.fill(start, 0);
            // Пока не нашли блокирующий поток...
            while ((add = dfs(s, t, INF)) != 0) {
                flow += add;
                version++;
            }
        }
        return flow;
    }
}
~~~~~~~~~~~~~~~~~~~~
[скачать](/src/Dinitz.java)

[Потоки минимальной стоимости](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B0_.D0.BE_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B5_.D0.BC.D0.B8.D0.BD.D0.B8.D0.BC.D0.B0.D0.BB.D1.8C.D0.BD.D0.BE.D0.B9_.D1.81.D1.82.D0.BE.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8)
============================

Пусть за каждую единицу потока, текущую по $i$-му ребру, нужно заплатить $w_i$
штрафа. Возникают две задачи:

* Какой минимальный штраф можно получить, пустив максимальный поток?
* Какой минимальный штраф можно получить, сделав хоть что-нибудь?

Максимальный поток минимальной стоимости
----------------------------------------

Максимальный поток минимальной стоимости искать очень просто --- нужно всего
лишь в алгоритме Форда-Беллмана выбирать каждый раз путь минимальной суммарной
стоимости.
Интуиция --- этот путь обладает минимальной стоимостью за литр пропущенной
жидкости, а логично брать дешёвые пути.

Сложность --- много ($O(VE \cdot |f|)$). Искать самый дешёвый путь --- алгоритмом
Форда-Беллмана (так как могут быть (и точно есть) отрицательные стоимости).

Поток минимальной стоимости
---------------------------

Искать также, как максимальный поток минимальной стоимости, но остановиться,
когда стоимость самого дешёвого пути стала положительной (так как тогда она и
в будущем будет положительной, что только увеличит штраф).

