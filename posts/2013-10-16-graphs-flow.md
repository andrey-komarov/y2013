---
title: Алгоритмы на графах: Потоки
---

Минимальные остовные деревья
===========================

[Алгоритм Краскала](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)
-------------------

На прошлом занятии был рассмотрен алгоритм построения остовного дерева в
невзвешенном графе: создаём [СНМ](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.A1.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B0_.D0.BD.D0.B5.D0.BF.D0.B5.D1.80.D0.B5.D1.81.D0.B5.D0.BA.D0.B0.D1.8E.D1.89.D0.B8.D1.85.D1.81.D1.8F_.D0.BC.D0.BD.D0.BE.D0.B6.D0.B5.D1.81.D1.82.D0.B2), перебираем рёбра, если ребром
соединяются элементы разных множеств, то добавляем его, объединяем множеста.

Алгоритм Краскала делает примерно то же самое. Хотим построить _минимальное_
остовное дерево. Отсортируем рёбра по возрастанию стоимости, пробежимся по ним
в этом порядке, добавляя в ответ те, которые соединяют разные множества в СНМ.
Результат будет минимальным остовным деревом.

[Алгоритм Прима](http://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9F%D1%80%D0%B8%D0%BC%D0%B0)
----------------

Алгоритм Краскала строил дерево, добавляя рёбра в произвольных местах графа.

Алгоритм Прима будет строить его, как бы "разрастая" остовное дерево от
какой-то начальной вершины. Будем хранить множество вершин, которые уже в
остовном дереве, и поддерживать для каждой вершины не из этого множества 
вес минимального ребра, ведущего в это множество.

После этого, будем каждый раз выбирать вершину, в которую идёт минимальное
ребро, добавлять её к ответу и пересчитывать минимальные расстояния

### Реализация

Граф хранится матрицей смежности, `-1`, если ребра нет. Считается, что граф
связный.

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = a[best][j];
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Сравние это с алгоритмом Дейкстры:

~~~~~~~~~~~~~~~~java
int[] d = new int[n];
Arrays.fill(d, INF);
d[0] = 0;
boolean[] used = new boolean[n];
for (int i = 0; i < n; i++) {
    int best = -1;
    for (int j = 0; j < n; j++) {
        if (!used[j] && (best == -1 || d[j] < d[best])) {
            best = j;
        }
    }
    used[best] = true;
    for (int j = 0; j < n; j++) {
        if (a[best][j] != -1) {
            continue;
        }
        int newW = d[best] + a[best][j]; // Смотреть сюда. Обещанная одна строчка
        if (d[j] > newW) {
            d[j] = newW;
        }
    }
}
~~~~~~~~~~~~~~~~~~~~

Кто лучше?
----------

Алгоритм Краскала работает за $O(E \cdot \log V)$ --- отсортировать рёбра,
пройтись по ним и добавлять в СНМ.

Рассмотренная реализация алгоритма Прима работает за $O(V^2)$.

Поэтому, оба алгоритма имеют право на жизнь: на графах, где рёбер много, лучше 
работает алгоритм Прима, а где мало --- Краскала.

Следует, однако, признать, что можно, аналогично алгоритму Дейкстры, реализовать
алгоритм Прима за те же самые $O(E \cdot \log V)$, но реализация будет сложнее,
чем реализация алгоритма Краскала.


Потоки
======

TBD

Потоки минимальной стоимости
============================

TBD
