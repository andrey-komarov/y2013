---
title: Дерево отрезков
mathjax: on
---

Большую часть этого занятия будет решаться довольно скучная задача:
Дан массив из $n$ чисел и много запросов одного из двух видов:

* Записать в $i$-ю ячейку число $a_i$;
* посчитать сумму чисел на отрезке с $l_i$-го по $r_i$-е.

[Корневая оптимизация](http://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8_%D0%BD%D0%B0_%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%B0%D1%85._%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D1%8D%D0%B2%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0)
======================

Имеет также названия _sqrt-декомпозиция_, _корневая эвристика_.

Пусть данный массив $a$ имеет длину $n$. Выберем некое число $k$. Что за число
следует взять в качестве $k$ станет понятно потом.

Разобъём массив на _блоки_ размера $k$. В последнем блоке может оказаться меньше,
чем $k$ элементов. Это нас устраивает. В каждом из блоков посчитаем сумму и
где-нибудь её сохраним.

Нужно научиться обрабатывать обозначенные выше два запроса. Начнём с простого.

* Чтобы обновить значение в ячейке массива, можно:
     1. Обновить его в массиве.
     2. Пересчитать сумму в блоке, содержащем обновлённый элемент.

Итого, эту операцию можно делать за $O(k)$ (пересчёт суммы).

Вторая операция несколько сложнее. Пусть пришёл запрос суммы на интервале
$[left; right)$. Есть несколько случаев:

* Весь интервал $[left; right)$ полностью содержится в каком-то из блоков.
В этом случае можно просто просуммировать все эти элементы, потратив $O(k)$
времени.
* Интервал не содержится целиком ни в одном из блоков.
В этом случае есть два _граничных блока_, не содержащихся в запросе полностью
и сколько-то блоков, полностью содержащихся в интервале запроса.
Тогда для нахождения суммы на интервале $[left; right)$:
    * найдём суммы элементов интервала в граничных блоках;
    * найдём сумму в блоков, попавших в запрос полностью. Таких не более $\frac{n}{k}$.

Итого, обработка одного запроса суммы выполняется за $O(\frac{n}{k} + k)$.
Пришло время выбрать $k$. Мы хотим, чтобы время работы было как можно меньшим.

Продифференцируем время работы по $k$ и приравняем производную к нулю:
$\frac{d(n/k+k)}{dk} = -\frac{n}{k^2} + 1 = 0$, $k = \sqrt{n}$.

Вывод: нужно брать $k \approx \sqrt{n}$, и будет вам счастье и обработка
запросов за $O(\sqrt{n})$. На практике,
можно просто поставить $k \approx 300$ и радоваться жизни. Если благорастворения
не наступило, подвигать туда-сюда эту константу.

[Дерево отрезков](http://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D1%81%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B_%D0%B8_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85#.D0.94.D0.B5.D1.80.D0.B5.D0.B2.D0.BE_.D0.BE.D1.82.D1.80.D0.B5.D0.B7.D0.BA.D0.BE.D0.B2)
================

Дерево отрезков является, в некотором роде, обобщением корневой эвристики.
Также, как и в корневой оптимизации, массив разбивается на части, для каждой
из них что-то считается и считается общий ответ.

Будем считать, что размер массива $n = 2^k$. Разобъём массив пополам, посчитаем
сумму в каждой половине, повторим для половин тот же процесс. Повторяем, пока
размер массива не станет равным единице.

Как это реализовывать?
----------------------

Вспомним, что происходило при реализации двоичной кучи. У вершины $i$ были
потомки $2i$ и $2i+1$. Сделаем здесь то же самое. Заведём массив длиной $2n$,
в элементах с $n$-го по $2n$-й которого будут лежать начальные элементы
начального массива. В первом будет лежать сумма всего массива, во втором ---
сумма на интервале $[0; \frac{n}2)$, в третьем --- $[\frac{n}2; n)$, ...
Если в $i$-й позиции хранится сумма на интервале $[L; R)$, то в $2i$-м ---
$[L; \frac{L+R}2)$, а в $2i+1$-м --- $[\frac{L+R}2; R)$.

В функцию нахождения суммы на отрезке будет передаваться интервал-подотрезок
массива, сумму на пересечении которого со вторым переданным интервалом хочется
посчитать.

[Реализация](/src/RangeTree.java)
------------

~~~~~~~~~~~~~~java
public class RangeTree {
    private int[] t;
    private int n;

    public RangeTree(int[] a) {
        for (n = 1; n < a.length; n *= 2)
            ;
        t = new int[2 * n];
        for (int i = 0; i < a.length; i++) {
            t[i + n] = a[i];
        }
        for (int i = n - 1; i >= 1; i--) {
            t[i] = t[2 * i] + t[2 * i + 1];
        }
    }

    public void set(int i, int val) {
        int v = n + i;
        t[v] = val;
        v /= 2;
        while (v != 0) {
            t[v] = t[2 * v] + t[2 * v + 1];
            v /= 2;
        }
    }

    public int get(int left, int right, int lBound, int rBound, int v) {
        if (left <= lBound && rBound <= right) {
            return t[v];
        }
        if (right <= lBound || rBound <= left) {
            return 0;
        }
        int mid = (lBound + rBound) / 2;
        return get(left, right, lBound, mid, 2 * v)
                + get(left, right, mid, rBound, 2 * v + 1);
    }

    public int get(int left, int right) {
        return get(left, right, 0, n, 1);
    }
}
~~~~~~~~~~~~~~~~~~

Что делать, если $n \ne 2^k$
----------------------------

Добьём массив до ближайшей степени двойки нулями. Длина увеличится не более,
чем в два раза.

Что можно считать?
==================

При реализации использовались:

* Свойство, что можно складывать числа в любом порядке.
* Волшебная константа $0$, которая возвращалась в случае непересечения
исследуемых отрезков и для дополнения массива до массива длиной степень двойки.

От нуля требовалось то, что при сложении с любым числом он даёт число, с которым
его складывают.

Моноид
------

Обобщим эти свойства и введём понятие _[моноида](http://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%BD%D0%BE%D0%B8%D0%B4)_.

_Моноид_ --- тройка $\langle A; 0; +\rangle$, где $A$ --- _носитель_, $+$ ---
операция композиции двух элементов множества $A$, $0$ --- нейтральный 
элемент множества $A$, при этом:

* Для любого $a$ из $A$: $0 + a = a + 0 = a$.
* $+$ ассоциативен: $(a + b) + c = a + (b + c)$.

Примеры моноидов
----------------

[Куча](http://en.wikipedia.org/wiki/Monoid#Examples) их. И по любому можно
построить дерево отрезков. И корневую оптимизацию тоже. Например:

* $\langle \mathrm{int}, 0, +\rangle$ --- сложение целых чисел. Нейтральный элемент --- $0$.
* $\langle \mathrm{int}, 1, \cdot\rangle$ --- умножение целых чисел.
* $\langle \mathbb{R}, +\infty, \min\rangle$ --- минимум чисел. 
* $\langle \mathrm{Matr_{n\times n}}, E_n, \cdot\rangle$ --- матрицы $n \times n$,
умножение. Нейтральный элемент --- единичная матрица $n \times n$.
* $\langle \Sigma^*, \varepsilon, \|\rangle$ --- строки, пустая строка, конкатенация.
* $\langle \mathbb{N}, 0, \mathrm{gcd} \rangle$ --- натуральные числа (надеюсь,
ни у кого не вызывает сомнений, что $0$ --- натуральное число), 0, наибольший
общий делитель.
* ~~$\langle A \to A, \mathrm{Id}, \circ \rangle$ --- автоморфизмы, тождественная
функция, композиция~~ Остапа несло. Хватит пока примеров.

Изменение на отрезке
====================

Рассмотрим новый тип запроса: добавить ко всем числам на интервале $[left; right)$
число $a$. 

Корневая оптимизация
--------------------

Можно решить следующим образом. Будем для каждого блока хранить не только
сумму чисел в этом блоке, но и _добавку_ --- сколько нужно добавить к каждому
элементу в этом блоке. Тогда во время счёта суммы можно во время счёта блоками,
добавлять ещё $add_i \cdot k$ к ответу для каждого блока $i$, лежащего внутри
запроса. То же самое делается с крайними блоками, не попавшими полностью в
запрос. Похожим образом обрабатывается изменение: два крайних блока обрабатываются
отдельно полностью, а тем, которые полностью лежат внутри запроса, к добавке
добавляется соответствующее значение.


[Дерево отрезков](http://neerc.ifmo.ru/wiki/index.php?title=%D0%9D%D0%B5%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F._%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BC%D0%B0%D1%81%D1%81%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
-----------------

Сделаем похожие "ленивые" добавки. Будем __всегда, когда пишем дерево отрезков
или другое дерево с массовыми операциями__ следовать плану:

1. Придя в очередную вершину, раздать потомкам информацию, которая записана в
в этой вершине.
2. Сделать запрос.
3. Перед выходом, пересчитать значение в вершине.

Например, если хранится, сколько добавлено на текущий отрезок, то алгоритм,
в тот момент, когда зашёл в какую-то вершину, должен увеличить эту добавку
потомкам на то число, которое записано в этой вершине, после чего обнулить
это значение, выполнить запрос (те три случая), после чего пересчитать значение
суммы в текущей вершине.
